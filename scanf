#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>
#include <math.h>


static int pushed_char = -1;
int read_char(void) {
    if (pushed_char != -1) {
        int c = pushed_char;
        pushed_char = -1;   // reset global variable
        return c;
    }
    return getchar();
}

void unread_char(int c) {
    pushed_char = c;
}

//ignore whitespace
void skip_whitespaces(void) {
    int c;
    while ((c = read_char()) != EOF) {
        if (!(c==' ' || c=='\t' || c=='\n' || c=='\r' || c=='\v' || c=='\f')) {
            unread_char(c);
            return;
        }
    }
}

// %d reading a decimal integer
int read_decimal(int *out) {
    int c;
    int sign = 1;
    int value = 0;
    int digits_read = 0;

    skip_whitespaces();

    c = read_char();
    if (c == '-') {
        sign = -1;
    } else if (c == '+') {
        sign = 1;
    } else {
        unread_char(c);
    }

    while ((c = read_char()) != EOF) {
        if (c >= '0' && c <= '9') {
            value = value * 10 + (c - '0');
            digits_read++;
        } else {
            unread_char(c);
            break;
        }
    }

    if (digits_read == 0) {
        return 0;   // failure
    }

    *out = sign * value;
    return 1;       // success
}
// read a single char %c
int read_char_specifier(char *out) {
    int c = read_char();
    if (c == EOF) return 0;  // fail
    *out = c;
    return 1;                // success
}

// read a string %s
int read_string(char *out) {
    int c;
    int len = 0;
    while ((c = read_char()) != EOF && c != '\0' && c != ' ' && c != '\n' && c != '\t') {
        out[len++] = c;
    }
    out[len] = '\0';
    return len > 0;  // success if at least 1 char read
}

int read_hex(int *out) {
    int c;
    int sign = 1;
    int value = 0;
    int digits_read = 0;
    int digit;

    skip_whitespaces();

    c = read_char();
    if (c == '-') {
        sign = -1;
    } else if (c == '+') {
        sign = 1;
    } else {
        unread_char(c);
    }

    while ((c = read_char()) != EOF) {
        if (c >= '0' && c <= '9') {
            digit = c - '0';
        }
        else if (c >= 'A' && c <= 'F') {
            digit = c - 'A' + 10;
        }
        else if (c >= 'a' && c <= 'f') {
            digit = c - 'a' + 10;
        }
        else {
            unread_char(c);
            break;
        }

        value = value * 16 + digit;
        digits_read++;
    }

    if (digits_read == 0) {
        return 0;
    }

    *out = sign * value;
    return 1;
}

int read_float(float *out) {
    int c;
    int sign = 1;
    float value = 0.0f;
    int digits_read = 0;

    skip_whitespaces();

    c = read_char();
    if (c == '-') sign = -1;
    else if (c == '+') sign = 1;
    else unread_char(c);

    // integer part
    while ((c = read_char()) != EOF && c >= '0' && c <= '9') {
        value = value * 10.0f + (c - '0');
        digits_read++;
    }

    // fractional part
    if (c == '.') {
        float fraction = 0.0f;
        float factor = 0.1f;
        int fraction_digits = 0;
        while ((c = read_char()) != EOF && c >= '0' && c <= '9') {
            fraction += (c - '0') * factor;
            factor *= 0.1f;
            digits_read++;
            fraction_digits++;
        }
        value += fraction;


        // if no digits after decimal, fail
        if (fraction_digits == 0 && digits_read == 0) {
            if (c != EOF) unread_char(c);
            return 0;

        }
    }

    if (c == 'e' || c == 'E') {
        int exponent_sign = 1;
        int exponent_digits = 0;
        int exponent_value = 0;

        c = read_char();
        if (c == '-') exponent_sign = -1;
        else if (c == '+') exponent_sign = 1;
        else unread_char(c);

        while ((c = read_char()) != EOF && c >= '0' && c <= '9') {
            exponent_value = exponent_value * 10 + (c - '0');
            exponent_digits++;
        }
        if (exponent_digits == 0) {
            if (c != EOF) unread_char(c);
            return 0;
        }
        if (c != EOF) unread_char(c);

        // apply exponent
        float factor = 1.0f;
        for (int i = 0; i < exponent_value; i++) factor *= 10.0f;
        if (exponent_sign == 1) value *= factor;
        else value /= factor;
    }

    if (digits_read == 0) return 0;
    *out = sign * value;
    if (c != EOF) unread_char(c);
    return 1;
}

//--------------------------------------------------//
//new custom modifiers//
//read binary number %b //

int read_binary(int *out) {
    int c;
    int sign = 1;
    int value = 0;
    int digits_read = 0;
    skip_whitespaces();

    c = read_char();
    if (c == '-') sign = -1;
    else if (c == '+') sign = 1;
    else unread_char(c);
    while ((c = read_char()) != EOF) {
        if ( c == '0' || c == '1') {
            value = value * 2 + (c - '0');
            digits_read++;
        }else {
            unread_char(c);
            break;
        }
    }
    if (digits_read == 0) return 0;
    *out = sign * value;
    return 1; //success
}

int read_line(char *out, int max_size) {
    char c;
    int index = 0;
    while (EOF != (c = read_char()) && c != '\n') {
        if (index < max_size - 1){
            out[index] = c;
            index++;
        }
    }
    out[index] = '\0';
    if (index == 0 && c == EOF) return 0;
    return 1;
}

int read_percentage(float *out) {
    float temp_float;
    int c;
    if (!read_float(&temp_float)) return 0;
    while ((c = read_char()) == ' ' || c == '\t');
    // c must be '%'
    if (c != '%') {
        if (c != EOF) unread_char(c);
        return 0;
    }
    *out = temp_float / 100.0f;
    return 1;
}

int my_scanf(const char *fmt, ...){
    va_list args;
    int assigned = 0;
    va_start(args, fmt);

    if (*fmt == '%' && *(fmt + 1) == 'd') {
        skip_whitespaces();
        int *ptr = va_arg(args, int *);
        if (read_decimal(ptr)) {
            assigned = 1;
        }
    }
    else if (*fmt == '%' && *(fmt + 1) == 'c') {
        char *ptr = va_arg(args, char *);
        if (read_char_specifier(ptr)) {
            assigned = 1;
        }
    }
    else if (*fmt == '%' && *(fmt + 1) == 's') {
        skip_whitespaces();
        char *ptr = va_arg(args, char *);
        if (read_string(ptr)) assigned = 1;
    }
    else if (*fmt == '%' && *(fmt + 1) == 'x') {
        skip_whitespaces();
        int *ptr = va_arg(args, int *);
        if (read_hex(ptr)) assigned = 1;
    }
    else if (*fmt == '%' && *(fmt + 1) == 'f') {
        skip_whitespaces();
        float *ptr = va_arg(args, float *);
        if (read_float(ptr)) assigned = 1;
    }

    else if (*fmt == '%' && *(fmt + 1) == 'b') {
        skip_whitespaces();
        int *ptr = va_arg(args, int *);
        if (read_binary(ptr)) {
            assigned = 1;
        }
    }
    else if (*fmt == '%' && *(fmt + 1) == 'L') {
        char *ptr = va_arg(args, char *);
        int max_size = va_arg(args, int);
        if (read_line(ptr, max_size)) {
            assigned = 1;
        }
    }
    else if (*fmt == '%' && *(fmt + 1) == 'p') {
        skip_whitespaces();
        float *ptr = va_arg(args, float *);
        if (read_percentage(ptr)) assigned = 1;
    }
    va_end(args);
    return assigned;
}

// --------------------Tests -------------------- //
#define FLOAT_EPSILON 0.0001f
#define ASSERT_FLOAT_EQ(actual, expected) \
    assert(fabsf((actual) - (expected)) < FLOAT_EPSILON)

FILE *redirect_stdin(const char *input) {
    size_t len = strlen(input);
    pushed_char = -1;
    FILE *f = fmemopen((void *)input, len+1, "r");
    assert(f != NULL);
    stdin = f;
    return f;
}

void restore_stdin(FILE *f) {
    fclose(f);
}

void test_decimal(void) {
    int x;
    FILE *f;

    f = redirect_stdin("42");
    assert(my_scanf("%d", &x));
    assert(x == 42);
    restore_stdin(f);

    f = redirect_stdin("-123");
    assert(my_scanf("%d", &x));
    assert(x == -123);
    restore_stdin(f);

    f = redirect_stdin("   77");
    assert(my_scanf("%d", &x));
    assert(x == 77);
    restore_stdin(f);

    printf("PASS: decimal tests\n");
}

void test_char(void) {
    char ch;
    FILE *f;

    f = redirect_stdin("A");
    assert(my_scanf("%c", &ch));
    assert(ch == 'A');
    restore_stdin(f);

    printf("PASS: char tests\n");
}

void test_string(void) {
    char str[100];
    FILE *f;

    f = redirect_stdin("hello");
    assert(my_scanf("%s", str));
    assert(strcmp(str, "hello") == 0);
    restore_stdin(f);

    f = redirect_stdin("   world");
    assert(my_scanf("%s", str));
    assert(strcmp(str, "world") == 0);
    restore_stdin(f);

    printf("PASS: string tests\n");
}

void test_binary(void) {
    int b;
    FILE *f;

    f = redirect_stdin("1011");
    assert(my_scanf("%b", &b));
    assert(b == 11);
    restore_stdin(f);

    f = redirect_stdin("000101");
    assert(my_scanf("%b", &b));
    assert(b == 5);
    restore_stdin(f);

    printf("PASS: binary tests\n");
}

void test_hex(void) {
    int x;
    FILE *f;

    f = redirect_stdin("1A3f");
    assert(my_scanf("%x", &x));
    assert(x == 0x1A3F);
    restore_stdin(f);

    f = redirect_stdin("-FF");
    assert(my_scanf("%x", &x));
    assert(x == -255);
    restore_stdin(f);

    printf("PASS: hex tests\n");
}

void test_float(void) {
    float fval;
    FILE *f;

    f = redirect_stdin("3.1415");
    assert(my_scanf("%f", &fval));
    ASSERT_FLOAT_EQ(fval, 3.1415f);
    restore_stdin(f);

    f = redirect_stdin("-1.5");
    assert(my_scanf("%f", &fval));
    ASSERT_FLOAT_EQ(fval, -1.5f);
    restore_stdin(f);

    f = redirect_stdin("2.5e3");
    assert(my_scanf("%f", &fval));
    ASSERT_FLOAT_EQ(fval, 2500.0f);
    restore_stdin(f);

    printf("PASS: float tests\n");
}

void test_percentage(void) {
    float p;
    FILE *f;

    f = redirect_stdin("50%");
    assert(my_scanf("%p", &p));
    ASSERT_FLOAT_EQ(p, 0.5f);
    restore_stdin(f);

    f = redirect_stdin("12.5%");
    assert(my_scanf("%p", &p));
    ASSERT_FLOAT_EQ(p, 0.125f);
    restore_stdin(f);

    printf("PASS: percentage tests\n");
}

void test_line(void) {
    char line[100];
    FILE *f;

    f = redirect_stdin("This is a full line\n");
    assert(my_scanf("%L", line, 100));
    assert(strcmp(line, "This is a full line") == 0);
    restore_stdin(f);

    f = redirect_stdin("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
    assert(my_scanf("%L", line, 10));
    assert(strlen(line) == 9);
    assert(strncmp(line, "ABCDEFGHI", 9) == 0);
    restore_stdin(f);

    printf("PASS: line tests\n");
}

void test_decimal_edges(void) {
    int x;
    FILE *f;

    f = redirect_stdin("+");
    assert(!my_scanf("%d", &x));
    restore_stdin(f);

    f = redirect_stdin("-");
    assert(!my_scanf("%d", &x));
    restore_stdin(f);

    f = redirect_stdin("000");
    assert(my_scanf("%d", &x) && x == 0);
    restore_stdin(f);

    f = redirect_stdin("12abc");
    assert(my_scanf("%d", &x) && x == 12);
    restore_stdin(f);

    f = redirect_stdin("abc");
    assert(!my_scanf("%d", &x));
    restore_stdin(f);

    printf("PASS: decimal edge cases\n");
}

void test_string_edges(void) {
    char s[10];
    FILE *f;

    f = redirect_stdin("");
    assert(!my_scanf("%s", s));
    restore_stdin(f);

    f = redirect_stdin("   ");
    assert(!my_scanf("%s", s));
    restore_stdin(f);

    f = redirect_stdin("hello world");
    assert(my_scanf("%s", s));
    assert(strcmp(s, "hello") == 0);
    restore_stdin(f);

    printf("PASS: string edge cases\n");
}
void test_float_edges(void) {
    float f;
    FILE *in;

    in = redirect_stdin(".");
    assert(!my_scanf("%f", &f));
    restore_stdin(in);

    in = redirect_stdin("1.");
    assert(my_scanf("%f", &f));
    ASSERT_FLOAT_EQ(f, 1.0f);
    restore_stdin(in);

    in = redirect_stdin(".5");
    assert(my_scanf("%f", &f));
    ASSERT_FLOAT_EQ(f, 0.5f);
    restore_stdin(in);

    in = redirect_stdin("1e");
    assert(!my_scanf("%f", &f));
    restore_stdin(in);

    in = redirect_stdin("1e-3");
    assert(my_scanf("%f", &f));
    ASSERT_FLOAT_EQ(f, 0.001f);
    restore_stdin(in);

    printf("PASS: float edge cases\n");
}

void test_binary_edges(void) {
    int b;
    FILE *f;

    f = redirect_stdin("2");
    assert(!my_scanf("%b", &b));
    restore_stdin(f);

    f = redirect_stdin("10102");
    assert(my_scanf("%b", &b));
    assert(b == 10); // 1010
    restore_stdin(f);

    f = redirect_stdin("-");
    assert(!my_scanf("%b", &b));
    restore_stdin(f);

    printf("PASS: binary edge cases\n");
}
void test_line_edges(void) {
    char buf[5];
    FILE *f;

    f = redirect_stdin("\n");
    assert(my_scanf("%L", buf, 5));
    assert(strcmp(buf, "") == 0);
    restore_stdin(f);

    f = redirect_stdin("abc");
    assert(my_scanf("%L", buf, 5));
    assert(strcmp(buf, "abc") == 0);
    restore_stdin(f);

    f = redirect_stdin("abcdef");
    assert(my_scanf("%L", buf, 5));
    assert(strcmp(buf, "abcd") == 0);
    restore_stdin(f);

    printf("PASS: line edge cases\n");
}

void test_percentage_edges(void) {
    float p;
    FILE *f;

    // missing % sign
    f = redirect_stdin("50");
    assert(!my_scanf("%p", &p));
    restore_stdin(f);

    // spaces before %
    f = redirect_stdin("12.5   %");
    assert(my_scanf("%p", &p));
    ASSERT_FLOAT_EQ(p, 0.125f);
    restore_stdin(f);

    // invalid character after number
    f = redirect_stdin("30x%");
    assert(!my_scanf("%p", &p));
    restore_stdin(f);

    // negative percentage
    f = redirect_stdin("-20%");
    assert(my_scanf("%p", &p));
    ASSERT_FLOAT_EQ(p, -0.2f);
    restore_stdin(f);

    // only % without number
    f = redirect_stdin("%");
    assert(!my_scanf("%p", &p));
    restore_stdin(f);


    printf("PASS: percentage edge cases\n");
}


int main(void) {
    test_decimal();
    test_char();
    test_string();
    test_binary();
    test_hex();
    test_float();
    test_percentage();
    test_line();
    test_decimal_edges();
    test_string_edges();
    test_float_edges();
    test_line_edges();
    test_percentage_edges();


    printf("ALL TESTS PASSED \n");
    return 0;
}
